# Основные компоненты браузера

1. **Пользовательский интерфейс** - кнопки, закладки, адресная строка.
2. **Исполнительная часть пользовательского интерфейса** - отрисовка основы - окон и панелей со списками. Не зависит от типа платформы, только от операционной системы.
3. **Модуль отображения** - вывод запрошенного на экран (анализ кода HTML и CSS). В Chrome - под каждую вкладку свой модуль.
4. **Механизм браузера** - управляет взаимодействием пользовательского интерфейса и модуля отображения.
5. **Сетевые компоненты** - выполнение сетевых запросов.
6. **Интерпритатор JavaScript**.
7. **Хранилище данных/Вэб-база данных**.

## Модуль отображения.

Для *Firefox* - Gecko, для *Safari*, *Chrome* - WebKit.

**Схема работы**:
Парсинг HTML (перевод тегов в узлы DOM-дерева содержания) -> Создание дерева отображения (извлечение информации о стилях их CSS и тегов style) -> Компоновка элементов (присвоение каждому узлу его координат) -> Отрисовка (с помощью исполнительской части пользовательского интерфейса).

**Отличия**: в терминологии: (Gecko/WebKit) дерево визуально оформленных элементов - дерево фреймов/дерево отображения(объектов); размещение элементов - обтекание(reflow)/компоновка(layout). + в Gecko существует доп. уровень между файлом HTML и деревом DOM - буфер содержания (content sink), который форматирует элементы DOM. В WebKit - совмещение (attachment).

При этом модуль отображения старается как можно раньше начать отрисовку, поэтому создание дерева отображения и компоновка могут начаться ещё до окончания анализа HTML. 

### Лексический анализ.

Разделение информации на лексемы (токены).Образуют словарь языка, конструктивные элементы для создания документов. 

Анализ выполняется двумя анализаторами - лексическим (разбирает входящие символы на токены) и синтаксическим (анализирует структуру документа согласно синтаксическим правилам, игнорирует переносы и отступы) => результат - синтаксическое дерево.

### Синтаксический анализ.

Преобразует код в пригодную для чтения и выполнения структуру. Результат - дерево узлов, которые передают структуру документа (*синтаксическое дерево* или *дерево синтаксического анализа*).

Синтаксический анализ работает на основе определённых правил, которые определяются форматом документа. Для каждого формата - свой словарь и синтаксис.

Запрашивает у лексического анализатора новый токен и проверяет на соответствие какому-либо синтаксическому правилу. Если удаётся - создаётся узел в синтаксическом дереве, если нет - откладывается и запрашивается новый. Так до момента, пока не найдутся все правила. Если для какой-то лексемы не нашлось => создается исключение.

Синтаксическое дерево - не всегда конечный результат, иногда это только этап - zB компиляция - компилятор для преобразование исходного кода в машинный разбирает код и составляет синтаксическое дерево, а потом на основе него создает документ с машинным кодом.

Синтаксические анализаторы бывают 2х типов: **восходящие** (обрабатывают последовательность символов и постепенно находят в ней синтаксические правила) и **нисходящие** (разбирают структуру верхнего уровня и проверяют соответствие правилам).

Для создания синтаксических анализаторов существуют специальные приложения - **генераторы**. В Webkit используются *Flex* (в него загружается файл с токенами - в формате регулярных выражений) и *Bison* (в него загружаются правила в формате BNF) ((они же *Leх* и *Yacc*)).

Словарь и синтаксис HTML определяется в спецификациях W3C. Но! Ни один из перечисленных анализаторов не подходит, так как HTML не такой строгий - может не хватать закрывающих тегов, но всё равно будет работать. Определение HTML задается в формате DTD (Document Type Definition). Этот формат содеожит все определения всех возможных эелементов, атрибутов и свойств. Существует несколько версий (в т.ч. строгий формат).

Полученное синтаксическое дерево состоит из элементов DOM (Document Object Model - объектная модель документа). В корне - объект Document. 

### Алгоритм лексического анализа.

С помощью стандартных восходящих/нисходящих алгоритмов невозможно, так как: 
1. "Щадящий" характер языка.
2. В браузерах есть обработка часто встречающихся ошибокю
3. Возможность повторного вхождения - могут добавляться токены благодаря *document.write*.

Алгоритм состоит из 2х частей - лексический анализ и построение дерева. Лексический анализ разбивает символы на токены - открывающие и закрывающие тэги + атрибуты (названия и значения). Агализатор обнаруживает токен и отдает его конструктору деревьев.

Исходное состояние анализатора - "данные". Как он доходит до символа "<", он меняет состояние на "открытый тэг". Если после идёт буква - то состояние меняется на "название тэга". И так до тех пор, пока не будет обнаружен символ ">". Токен считается готовым, состояние снова меняется на "данные". Если дальше идёт текст, то для каждого символа будет создан новый токен. Если далее - символ "<", то состояние снова меняется на "открытый тэг" . Символ "/" меняет состояние на "название тэга" и ведёт к созданию закрывающего тэга.

### Построение дерева.

При создании синтаксического анализатора формируется объект Document. Для каждого токена создается свой элемент DOM, + элементы добавляются в стэк открытых элементов, чтобы исправлять ошибки и закрывать тэги. 

В начале построения дерева есть последовательность токенов - результат работы лексического анализатора. Изначальное состояние - *исходное*. При получении токена HTML меняется на *до HTML*, обрабатывается ещё раз. В результате создается HTMLHtmlElement. Состояние меняется на *до head*. Если head в документе нет, он все равно будет создан. Состояние при этом поменяется сначала на *внутри head*, затем на *после head*. Токен body обработается ещё раз, создаст элемент HTMLBodyElement, состояние изменится на *внутри body*. Если дальше будет просто текст, то для этого создастся текстовый узел, к которому будут прибавлены оставшиеся символы. После закрывающего тэга body состояние меняется на *после body*, после закрывающего HTML - *после после body*. Анализ завершается, начинается анализ отложенных скриптов. Затем состояние меняется на "готово", вызывается событие load.

### Синтаксический анализ CSS.

В CSS используется бесконтекстная грамматика, поэтому здесь подходят стандартные средства. Словарь определяется регулярными выражениями для каждого токена. Синтаксические правила описаны в формате BNF. 

#### Анализ CSS в Webkit.

Для анализа используются генераторы Flex и Bison. CSS разбивается на объекты StyleSheet с правилами. Объект правил содердит селектор, объявление (свойство: значение) и другие объекты, характерные для CSS.

