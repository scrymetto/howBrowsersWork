# Основные компоненты браузера

1. **Пользовательский интерфейс** - кнопки, закладки, адресная строка.
2. **Исполнительная часть пользовательского интерфейса** - отрисовка основы - окон и панелей со списками. Не зависит от типа платформы, только от операционной системы.
3. **Модуль отображения** - вывод запрошенного на экран (анализ кода HTML и CSS). В Chrome - под каждую вкладку свой модуль.
4. **Механизм браузера** - управляет взаимодействием пользовательского интерфейса и модуля отображения.
5. **Сетевые компоненты** - выполнение сетевых запросов.
6. **Интерпритатор JavaScript**.
7. **Хранилище данных/Вэб-база данных**.

## Модуль отображения.

Для *Firefox* - Gecko, для *Safari*, *Chrome* - WebKit.

**Схема работы**:
Парсинг HTML (перевод тегов в узлы DOM-дерева содержания) -> Создание дерева отображения (извлечение информации о стилях их CSS и тегов style) -> Компоновка элементов (присвоение каждому узлу его координат) -> Отрисовка (с помощью исполнительской части пользовательского интерфейса).

**Отличия**: в терминологии: (Gecko/WebKit) дерево визуально оформленных элементов - дерево фреймов/дерево отображения(объектов); размещение элементов - обтекание(reflow)/компоновка(layout). + в Gecko существует доп. уровень между файлом HTML и деревом DOM - буфер содержания (content sink), который форматирует элементы DOM. В WebKit - совмещение (attachment).

При этом модуль отображения старается как можно раньше начать отрисовку, поэтому создание дерева отображения и компоновка могут начаться ещё до окончания анализа HTML. 

### Лексический анализ.

Разделение информации на лексемы (токены).Образуют словарь языка, конструктивные элементы для создания документов. 

Анализ выполняется двумя анализаторами - лексическим (разбирает входящие символы на токены) и синтаксическим (анализирует структуру документа согласно синтаксическим правилам, игнорирует переносы и отступы) => результат - синтаксическое дерево.

### Синтаксический анализ.

Преобразует код в пригодную для чтения и выполнения структуру. Результат - дерево узлов, которые передают структуру документа (*синтаксическое дерево* или *дерево синтаксического анализа*).

Синтаксический анализ работает на основе определённых правил, которые определяются форматом документа. Для каждого формата - свой словарь и синтаксис.

Запрашивает у лексического анализатора новый токен и проверяет на соответствие какому-либо синтаксическому правилу. Если удаётся - создаётся узел в синтаксическом дереве, если нет - откладывается и запрашивается новый. Так до момента, пока не найдутся все правила. Если для какой-то лексемы не нашлось => создается исключение.

Синтаксическое дерево - не всегда конечный результат, иногда это только этап - zB компиляция - компилятор для преобразование исходного кода в машинный разбирает код и составляет синтаксическое дерево, а потом на основе него создает документ с машинным кодом.

Синтаксические анализаторы бывают 2х типов: **восходящие** (обрабатывают последовательность символов и постепенно находят в ней синтаксические правила) и **нисходящие** (разбирают структуру верхнего уровня и проверяют соответствие правилам).

Для создания синтаксических анализаторов существуют специальные приложения - **генераторы**. В Webkit используются *Flex* (в него загружается файл с токенами - в формате регулярных выражений) и *Bison* (в него загружаются правила в формате BNF) ((они же *Leх* и *Yacc*)).

Словарь и синтаксис HTML определяется в спецификациях W3C. Но! Ни один из перечисленных анализаторов не подходит, так как HTML не такой строгий - может не хватать закрывающих тегов, но всё равно будет работать. Определение HTML задается в формате DTD (Document Type Definition). Этот формат содеожит все определения всех возможных эелементов, атрибутов и свойств. Существует несколько версий (в т.ч. строгий формат).

Полученное синтаксическое дерево состоит из элементов DOM (Document Object Model - объектная модель документа). В корне - объект Document. 

### Алгоритм лексического анализа.

С помощью стандартных восходящих/нисходящих алгоритмов невозможно, так как: 
1. "Щадящий" характер языка.
2. В браузерах есть обработка часто встречающихся ошибокю
3. Возможность повторного вхождения - могут добавляться токены благодаря *document.write*.

Алгоритм состоит из 2х частей - лексический анализ и построение дерева. Лексический анализ разбивает символы на токены - открывающие и закрывающие тэги + атрибуты (названия и значения). Агализатор обнаруживает токен и отдает его конструктору деревьев.

Исходное состояние анализатора - "данные". Как он доходит до символа "<", он меняет состояние на "открытый тэг". Если после идёт буква - то состояние меняется на "название тэга". И так до тех пор, пока не будет обнаружен символ ">". Токен считается готовым, состояние снова меняется на "данные". Если дальше идёт текст, то для каждого символа будет создан новый токен. Если далее - символ "<", то состояние снова меняется на "открытый тэг" . Символ "/" меняет состояние на "название тэга" и ведёт к созданию закрывающего тэга.

### Построение дерева.

При создании синтаксического анализатора формируется объект Document. Для каждого токена создается свой элемент DOM, + элементы добавляются в стэк открытых элементов, чтобы исправлять ошибки и закрывать тэги. 

В начале построения дерева есть последовательность токенов - результат работы лексического анализатора. Изначальное состояние - *исходное*. При получении токена HTML меняется на *до HTML*, обрабатывается ещё раз. В результате создается HTMLHtmlElement. Состояние меняется на *до head*. Если head в документе нет, он все равно будет создан. Состояние при этом поменяется сначала на *внутри head*, затем на *после head*. Токен body обработается ещё раз, создаст элемент HTMLBodyElement, состояние изменится на *внутри body*. Если дальше будет просто текст, то для этого создастся текстовый узел, к которому будут прибавлены оставшиеся символы. После закрывающего тэга body состояние меняется на *после body*, после закрывающего HTML - *после после body*. Анализ завершается, начинается анализ отложенных скриптов. Затем состояние меняется на "готово", вызывается событие load.

### Синтаксический анализ CSS.

В CSS используется бесконтекстная грамматика, поэтому здесь подходят стандартные средства. Словарь определяется регулярными выражениями для каждого токена. Синтаксические правила описаны в формате BNF. 

#### Анализ CSS в Webkit.

Для анализа используются генераторы Flex и Bison. CSS разбивается на объекты StyleSheet с правилами. Объект правил содержит селектор, объявление (свойство: значение) и другие объекты, характерные для CSS.

### Порядок обработки скриптов и стилей.

Вэб-документы обрабатываются синхронно. Если встречается тэг "script", то синтаксический анализ останавливается до тех пор, пока скрипт не выполнится. Если скрипт внешний, то запрашиваются сетевые данные, анализ откладывается до получения ресурсов. Можно было пометить скрипт тегом *defer*, чтобы синтаксический анализ можно было выполнять до завершения скрипта. В HTML5 появились асинхронные скрипты, которые анализируются выполняются в другом потоке.

И в Webkit, и в Firefox используется **ориентировочный синтаксический анализ**, который выполняется в другом потоке , оценивает и загружает другие ресурсы. НО! НЕ изменяет дерево DOM, обрабатывает только внешние ресурсы (таблицы стилей, картинки и внешние скрипты).

Таблицы стилей не вносят извенения в дерево, поэтому нет смысла останавливать синтаксический анализ. НО! некоторые скрипты могут ссылаться на стили, если они не будут загружены, то информация не будет верной.Поэтому Firefox останавливает все скрипты, когда обнаруживает таблицу стилей, Webkit останавливает только в том случае, если пытаются извлечь стили, которые ещё не загружены.

### Дерево отображения.

Во время построения дерева DOM браузер создает ещё одну структуру - дерево отображения. Объекты этого дерева в Firefox называются фреймами (frame), в Webkit - объект отображения (render object). Каждый объект располагает данными о себе и о своих дочерних элементах. Представляет собой прямоугольную область, которая соответствует окну CSS-узла. Содержит в себе геометрические данные (ширина, высота и положение). Тип окна зависит от атрибута *display* объекта style, назначенного этому узлу.

Объекты дерева отображения соответствуют элементам DOM, но не идентичны им. То, что не отображается на экране не включается в дерево отображения. В то же время существуют такие элементы DOM, которым соответствуют сразу несколько объектов отображения, например, select - для него есть список, область отображения и кнопка. Некоторым объектам соответствует узел DOM, но положения не совпадают - объекты с абсолютным положением или плавающие помещаются в отдельную часть дерева.

### Построение дерева отображения.

В Firefox возуальное представление - слушатель изменений DOM-дерева. Созданием фреймов занимается *FrameConstructor*, он определяет стили и создает фрейм.

В Webkit определение стиля и совмещение объекта отображения называется *совмещением (attachment)*. Каждый узел DOM имеет метод `attach`. Совмещение происходит синхронно. При добавлении нового узла в DOM вызывается его метод `attach`.

В результате обработки тэгов html и body создаётся корневой объект дерева отображения - контейнер, блок верхнего уровня в CSS. Его размеры формируют область просмотра - *ViewPortFrame* в Firefox и *RenderView* в WebKit.Остальное дерево строится в ходе добавления в него узлов DOM.

Для построения дерева требуется рассчитать визуальные стили для каждого объекта. Они выстраиваются из данных пользователя, тегов style, внешних таблиц стилей. **Сложности:**

1. Таблицы могут быть объемными => проблемы с памятью.
2. Поиск правила для объекта может быть долгим из-за сложного селектора (приходится обходить все дерево, а стиль так и не применится - zB `div div div div {...}`).
3. Таблицы стилей подразумевают иерархию и сложно перекрывающие друг друга правила.

**Решение  WebKit**

Узлам соответствуют объекты RenderStyle, которые могут одновременно использоваться разными узлами только если узлы на одном уровне и выполняются условия:

1. состояния ссылок, фокуса и мыши одинаковые;
2. не прописан id;
3. атрибуты одинаковые;
4. атрибуты классов одинаковые;
5. одинаковые тэги;
6. не заданы атрибуты style.

**Решение  Firefox**

Создание 2х дополнительных структур: дерева контекстов и дерева правил. 

В *контексте стилей* содержатся уже рассчитанные значения (рассчитываются путём применения всех правил в нужном порядке + если в css указывались логические значения (процент от экранаб etc.)).
В *дереве правил* сохраняются все последовательности подходящих правил. Не рассчитывается для каждого узла + если последовательность правил уже существует в какой-либо ветке, этот кусок ветки просто копируется в нужное место.

**Классификация правил**

Все стили берутся из 3х источников: css, style-атрибуты и визуальные атрибуты css (`<p bgcolor="blue" />`). Составление правил - не так уж однозначно, поэтому они классифицируются. После составления синтаксического дерева правила добавляется в одну или несколько хэш-карт - по селектору, по классу, по id. Это ускоряет процесс. Используется в обоих типах браузеров. 

**Порядок приоритета**

1. Важные правила пользователя;
2. важные правила автора;
3. обычные автора;
4. обычные пользователя;
5. браузера.

#### Компоновка

Когда объект появляется в дереве отображения, он не имеет ни размеров, ни координат. Расчёт их называется компоновкой (reflow/layout). HTML - поточная модель компоновки (все последующие элементы НЕ влияют на предыдущие), поэтому в большинстве случаев делается один проход (исключение - таблицы). Рассчет происходит от левой верхней точки. Корневой элемент - <html> имеет координаты 0, 0 и занимает всю область просмотра. Затем рассчитывается иерархия фреймов/объектов отображения. 

Чтобы не выполнять перекомпоновку при каждом изменении, браузеры помечают изменившие своё положение компоненты как "грязные" - при этом есть 2 вида флага - `dirty` и `children are dirty`. 

Если меняется компоновка всего дерева, то она называется *глобальной* - это происходит только в 2х случаях:
1. Глобальное изменение (например, шрифта во всем документе);
2. Изменение размеров экрана.

При инкрементальной компоновке изменяются только "грязные объекты". Перекомпоновка происходит асинхронно - в Firefox команды откладываются в очередь, потом планировщик запускает их асинхронно. В Webkit выполнение также откладывается, чтобы потом за раз пройти сразу все дерево.

Если компоновка вызвана событием resize или изменением положения (но не размера), то размеры объекта берутся из кэша, объект не перерассчитывается заново, дерево не перекомпонуется заново.

**Процесс компоновки**

1. Родительский элемент определяет собственную ширину.
2. Родительский элемент обрабатывает дочерние элементы:
    1. определяет положение дочерноего элементаж
    2. вызов компоновки дочернего элемента, в результате чего определяется его высота
3. На основе суммы высот дочерних элементов, высоты полей и отступов рассчитывается высота родительского элемента.
4. Биты больше не помен=чаются, как "грязные".

Если используется перенос строк, то компоновка останавливается, передаётся запрос родительскому элементу, тот создает новый объект отображения и вызывает их компоновку.

#### Отрисовка

Для каждого объекта отрисовки вызывается метод paint и содержание выводится на экран. При глобальной отрисовки отрисовывается дерево целиком, при инкрементой - только отдельные объекты.Изменённый объект помечает свой прямоугольник, как недействительный, операционная система помечает его как "грязный". При этом области объединяются, чтобы отрисовать как можно больше всего за раз. 

**Порядок отрисовки**

Соответствует порядку помещения элементов в контексты стеков:

1. Цвет фона;
2. Фоновое изображение;
3. Рамка;
4. Дочерние объекты;
5. Внешние границы.

#### Изменения

При динамических изменениях браузеры стараются не делать лишних операций. При изменении цвета одного элемента, другие элементы не отрисовываются заново. При изменении положения выполняется повторная компоновка и отрисовка его, его дочерних элементов и, возможно, других объектов того же уровня. Глобальные изменения ведут к очистке кэша и повторной компоновке и отрисовке всего дерева.

### Потоки модуля отображения.

Модуль отображения работает в одном потоке, в нём выполняется все, кроме сетевых запросов. Сетевые запросы могут выполняться в параллельных потоках (от 2 до 6).

Основной поток представляет собой бесконечный цикл, который ожидает отправки событий (layout или print), чтобы их обработать.

### Визуальная модель CSS2

Canvas - пространство, где отображается отформатированная структура. Бесконечен, но браузеры определяют ширину, исходя из размеров области просмотра.

#### Схема позиционирования.

Всего 3:
1. Стандартная - согласно своему положению в дереве.
2. Плавающая - сначала по стандартной схеме, затем смещается в крайнее правое или крайнее левое положение.
3. Абсолютная - отличается от положения в дереве.

Схема определяется свойством `position` и атрибутом `float`:

* `static` и `relative` - стандартная схема;
* `absolute` и `fixed` - абсолютная.

При этом в `static` положение не задаётся - используется по умолчанию.

**Блочный элемент** создает собственный блок в браузере, строчный не имеет собственный блок, поэтому помещается в контейнер. *Блочные* элементы размещаются друг под другом, *строчные* - друг рядом с другом. *Строчные* элементы объединяются в строки, если ширина контейнера не достаточна, то элементы переносятся на следующие строки.

*Относительное позиционирование (relative)* означает, что объект размещается стандартным способом, а затем смещается относительно его.

*Плавающее окно (float)* смещается влево или вправо относительно строки. Остальное содержание будет его обтекать.

*Фиксированное позиционирование* исключается из общей схемы, остается на месте даже при прокрутке.

**z-index** влияет на то, что будет отрисовано выше (при его отсутствии чем дальше элемент, тем ближе к пользователю он будет).